using System.Collections.Generic;using UnityEngine;using System.Text.RegularExpressions;using System.IO;public class BTEvolver : MonoBehaviour {    [Header("Tasks Available on the Behavior Tree")]    public string[] actions;    public string[] conditionals;    public string[] composites;    [Header("Maximun number of children per node")]    public int n;    [Header("Maximum initial depth per tree")]    public int maxInitialDepth;    [Header("Name to use in the txt files (witouth the .txt extension)")]    public string populationName;    public int populationSize;    public TextAsset txtPopulation;    BTGenotype [] population;    private int obtainableTree;    private int[] numberOfTrees;    public double mutationFactor;    string randomActionTaskName(){        return actions[Random.Range(0, actions.Length)];    }    string randomConditionalTaskName(){        return conditionals[Random.Range(0, conditionals.Length)];    }    string randomTerminalTaskName(){        if(Random.Range(0,100)>=27){            return actions[Random.Range(0,actions.Length)];        }else{            return conditionals[Random.Range(0, conditionals.Length)];        }    }    string randomInternalTaskName(){        return composites[Random.Range(0, composites.Length)];    }    BTNode subTreeFullMethod(int currentDepth, int maxDepth, int currentNodeIndex){        if(currentDepth>=maxDepth){            return new BTNode(n, currentNodeIndex, randomTerminalTaskName());        }else{            BTNode ans = new BTNode(n, currentNodeIndex, randomInternalTaskName());            int childrenN = Random.Range(2, n + 1);            for (int i = 1; i <= childrenN;i++){                int childIndex = currentNodeIndex * n + i;                BTNode child = subTreeFullMethod(currentDepth + 1, maxDepth, childIndex);                ans.addChild(child);            }            return ans;        }    }    BTGenotype genotypeByFullMethod(int maxDepth){        BTNode root = subTreeFullMethod(1, maxDepth,0);        BTGenotype ans = new BTGenotype(root);        return ans;    }    BTNode subTreeGrowMethod(int currentDepth, int maxDepth, int currentNodeIndex){        if(currentDepth>=maxDepth || Random.Range(0,100)<20){            return new BTNode(n, currentNodeIndex, randomTerminalTaskName());        }else{            BTNode ans = new BTNode(n, currentNodeIndex, randomInternalTaskName());            int childrenN = Random.Range(2, n + 1);            for (int i = 1; i <= childrenN;i++){                int childIndex = currentNodeIndex * n + i;                BTNode child = subTreeFullMethod(currentDepth + 1, maxDepth, childIndex);                ans.addChild(child);            }            return ans;        }    }    BTGenotype genotypeByGrowMethod(int maxDepth){        BTNode root = subTreeGrowMethod(1, maxDepth, 0);        BTGenotype ans = new BTGenotype(root);        return ans;    }    void createPopulationRandomly(){        int index = 0;        for (int i = 0; i < populationSize / 2; i++){            population[index++] = genotypeByFullMethod(maxInitialDepth);            //Debug.Log(population[i].ToString());        }        for (int i = 0; i < populationSize / 2; i++){            population[index++] = genotypeByGrowMethod(maxInitialDepth);            //Debug.Log(population[populationSize/2+i].ToString());        }    }    void recoverPopulation(){        string populationStr = PlayerPrefs.GetString("populationStr");        string[] lines = Regex.Split(populationStr,"\n");        for (int i = 0; i < populationSize; i++){            string[] nodesStr = lines[i].Split('_');            population[i] = new BTGenotype(n, nodesStr, maxInitialDepth * 2);            //Debug.Log(population[i].ToString());        }    }    double getPopulationFitnessMean(){        double ans = 0.0;        for (int i = 0; i < populationSize; i++){            ans += population[i].getFitness();        }        ans /= populationSize;        return ans;    }    double getPopulationFitnessStdDev(){        double ans = 0.0f;        double mean = getPopulationFitnessMean();        for (int i = 0; i < populationSize; i++){            double term = population[i].getFitness() - mean;            ans += Mathf.Pow((float)term, 2);        }        ans = Mathf.Sqrt((float)ans / (populationSize - 1));        return ans;    }    void normalisePopulationFitness(){        double mean = getPopulationFitnessMean();        double stdDev = getPopulationFitnessStdDev();        for (int i = 0; i < populationSize; i++){            population[i].normaliseFitness(mean, stdDev);        }    }    BTGenotype getCrossover(BTGenotype p1, BTGenotype p2){        BTGenotype parent1 = p1.getCopy();        BTGenotype parent2 = p2.getCopy();        /*Debug.Log("*******Performing Crossover*******");        Debug.Log(parent1.ToString());        Debug.Log(parent2.ToString());*/        BTNode n1 = parent1.getRandomSubTree();        BTNode n2 = parent2.getRandomSubTree();        //Debug.Log("N1: " + n1.ToString() + " N2: " + n2.ToString());        parent1.replaceSubTreeWithRoot(n1.index, n2);        parent2.replaceSubTreeWithRoot(n2.index, n1);        parent1.restructureBTIndexes();        parent2.restructureBTIndexes();        parent1.pruneGenotype(conditionals, actions);        parent2.pruneGenotype(conditionals, actions);        /*Debug.Log("*****Crossover Result*****");        Debug.Log(parent1.ToString());        Debug.Log(parent2.ToString());*/        if (Random.Range(0, 100) < 50) return parent1;        return parent2;    }    BTGenotype getFitnessProportionate(List<BTGenotype> group){        double r = Random.Range(0.0f, 1.0f);        BTGenotype ans = null;        double total = 0.0f;        for (int i = 0; i < group.Count; i++){            total += group[i].getFitness();            if (total > r){                ans = group[i];            }        }        if (ans == null){            ans = group[group.Count - 1];        }        return ans;    }    BTGenotype getRandomParent(List<BTGenotype> group1, List<BTGenotype> group2){        int r = Random.Range(0, 100);        if (r < 50) return getFitnessProportionate(group1);        return getFitnessProportionate(group2);    }    void evolvePopulation(){        normalisePopulationFitness();        List<BTGenotype> list = new List<BTGenotype>();        for (int j = 0; j < populationSize; j++){            list.Add(population[j]);        }        list.Sort((a, b) => -1 * a.CompareTo(b));        for (int j = 0; j < populationSize; j++){            population[j] = list[j];        }        // create two groups to pick genotypes based on fitness        List<BTGenotype> group1 = new List<BTGenotype>();        List<BTGenotype> group2 = new List<BTGenotype>();        int i = 0;        for (; i < populationSize * 0.2; i++){            group1.Add(population[i]);        }        for (; i < populationSize; i++){            group2.Add(population[i]);        }        BTGenotype [] temp = new BTGenotype[populationSize];        for (int j = 0; j < populationSize; j++){            BTGenotype parent1 = getRandomParent(group1, group2);            BTGenotype parent2 = getRandomParent(group1, group2);            temp[j] = getCrossover(parent1,parent2);        }        population = temp;    }    bool isActionTask(string taskName){        for (int i = 0; i < actions.Length; i++){            if (actions[i].Equals(taskName)) return true;        }        return false;    }    bool isConditionalTask(string taskName){        for (int i = 0; i < conditionals.Length; i++){
            if (conditionals[i].Equals(taskName)) return true;
        }        return false;    }    void populationMutation(){        int totalOfNodes = 0;        for (int i = 0; i < populationSize; i++){            totalOfNodes += population[i].numberOfNodes();        }        int nodesToModify = (int)( totalOfNodes * mutationFactor );        for (int i = 0; i < nodesToModify; i++){            int index = Random.Range(0, populationSize);            BTGenotype genotype = population[index];            BTNode nodeToChange = genotype.getRandomSubTree();            string newTaskName = "";            if(nodeToChange.isLeafNode()){                int rand = Random.Range(0, 100);                if(rand<15){                    newTaskName = randomTerminalTaskName();                }else {                    if(isActionTask(nodeToChange.taskName)){                        newTaskName = randomActionTaskName();                    }else{                        newTaskName = randomConditionalTaskName();                    }                }            }else{                newTaskName = randomInternalTaskName();            }            nodeToChange.setTaskName(newTaskName);        }    }    void recoverInitialPopulationFromFile(){        string strPopulation = txtPopulation.text;        string[] lines = Regex.Split(strPopulation, "\n");        for (int i = 0; i < populationSize; i++){            string[] nodesStr = lines[i].Split('_');            population[i] = new BTGenotype(n, nodesStr, maxInitialDepth * 2);            //Debug.Log(population[i].ToString());        }    }    void createCurrentPopulation(){        int mode = PlayerPrefs.GetInt("evolverMode", 0);        int generation = PlayerPrefs.GetInt("generationNumber", -1);        Debug.Log("Current Generation: " + generation);        Debug.Log("Evolver Mode; " + mode);        // random mode        if(mode==0){            // create initial population randomly            if(generation<0){                createPopulationRandomly();            }else{                recoverPopulation();                storePreviousPopulation();                evolvePopulation();                populationMutation();            }        }else{            if(generation<0){                recoverInitialPopulationFromFile();            }else{                recoverPopulation();                storePreviousPopulation();                evolvePopulation();                populationMutation();            }        }    }    public void initEvolver(){        population = new BTGenotype[populationSize];        numberOfTrees = new int[populationSize];        obtainableTree = 0;        createCurrentPopulation();    }    public void finishEvolver(){        setFinalFitnessToPopulation();        storeCurrentPopulation();    }    public void addFitnessToGenotype(int treeIndex, double fitnessToAdd){        population[treeIndex].incrementFitness(fitnessToAdd);    }    public int getNextTreeIndex(){        return obtainableTree;    }    public BTGenotype getNextTree(){        BTGenotype ans = population[obtainableTree];        numberOfTrees[obtainableTree]++;        obtainableTree++;        obtainableTree %= populationSize;        return ans;    }    public void setFinalFitnessToPopulation(){        for (int i = 0; i < populationSize; i++){            population[i].divideFitness(numberOfTrees[i]);        }    }    void printPopulation(){        Debug.Log("////////////////");        for (int i = 0; i < populationSize; i++){            Debug.Log(population[i].ToString());        }        Debug.Log("////////////////");        Debug.Log(Application.dataPath);    }    void storePreviousPopulation(){        int generation = PlayerPrefs.GetInt("generationNumber");        string content = "Generation: "+generation + "\n";        double mean = getPopulationFitnessMean();        double stdDev = getPopulationFitnessStdDev();        content += "Mean: " + mean + "\n";        content += "Std Dev: " + stdDev + "\n";        for (int i = 0; i < populationSize;i++){            content += population[i].ToString()+"\n";        }        string path = "/Users/dstisystem/Desktop/Generations/WormTrees" + generation.ToString() + ".txt";        File.WriteAllText(path,content);    }    void storeCurrentPopulation(){        int newGenerationNumber = PlayerPrefs.GetInt("generationNumber", -1) + 1;        string populationStr = "";        for (int i = 0; i < populationSize; i++){            populationStr += population[i].ToString() + "\n";        }        PlayerPrefs.SetString("populationStr", populationStr);        PlayerPrefs.SetInt("generationNumber", newGenerationNumber);    }}